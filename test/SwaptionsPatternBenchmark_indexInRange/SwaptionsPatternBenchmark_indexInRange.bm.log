# JMH version: 1.35
# VM version: JDK 18.0.2, OpenJDK 64-Bit Server VM, 18.0.2+0
# VM invoker: /usr/lib/jvm/java-18-openjdk/bin/java
# VM options: --add-modules=jdk.incubator.vector
# Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: jvbench.swaptions.SwaptionsPatternBenchmark.indexInRange

# Run progress: 0.00% complete, ETA 00:08:20
# Fork: 1 of 5
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 0.591 ops/s
# Warmup Iteration   2: 0.575 ops/s
# Warmup Iteration   3: 0.585 ops/s
# Warmup Iteration   4: 0.581 ops/s
# Warmup Iteration   5: 0.578 ops/s
Iteration   1: 0.571 ops/s
Iteration   2: 0.574 ops/s
Iteration   3: 0.585 ops/s
Iteration   4: 0.566 ops/s
Iteration   5: 0.575 ops/s

# Run progress: 20.00% complete, ETA 00:07:09
# Fork: 2 of 5
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 0.564 ops/s
# Warmup Iteration   2: 0.580 ops/s
# Warmup Iteration   3: 0.597 ops/s
# Warmup Iteration   4: 0.589 ops/s
# Warmup Iteration   5: 0.589 ops/s
Iteration   1: 0.587 ops/s
Iteration   2: 0.571 ops/s
Iteration   3: 0.581 ops/s
Iteration   4: 0.579 ops/s
Iteration   5: 0.577 ops/s

# Run progress: 40.00% complete, ETA 00:05:17
# Fork: 3 of 5
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 0.564 ops/s
# Warmup Iteration   2: 0.625 ops/s
# Warmup Iteration   3: 0.624 ops/s
# Warmup Iteration   4: 0.621 ops/s
# Warmup Iteration   5: 0.626 ops/s
Iteration   1: 0.620 ops/s
Iteration   2: 0.615 ops/s
Iteration   3: 0.582 ops/s
Iteration   4: 0.621 ops/s
Iteration   5: 0.623 ops/s

# Run progress: 60.00% complete, ETA 00:03:35
# Fork: 4 of 5
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 0.572 ops/s
# Warmup Iteration   2: 0.623 ops/s
# Warmup Iteration   3: 0.622 ops/s
# Warmup Iteration   4: 0.624 ops/s
# Warmup Iteration   5: 0.621 ops/s
Iteration   1: 0.622 ops/s
Iteration   2: 0.620 ops/s
Iteration   3: 0.623 ops/s
Iteration   4: 0.623 ops/s
Iteration   5: 0.619 ops/s

# Run progress: 80.00% complete, ETA 00:01:48
# Fork: 5 of 5
WARNING: Using incubator modules: jdk.incubator.vector
# Warmup Iteration   1: 0.546 ops/s
# Warmup Iteration   2: 0.591 ops/s
# Warmup Iteration   3: 0.594 ops/s
# Warmup Iteration   4: 0.625 ops/s
# Warmup Iteration   5: 0.623 ops/s
Iteration   1: 0.627 ops/s
Iteration   2: 0.625 ops/s
Iteration   3: 0.607 ops/s
Iteration   4: 0.622 ops/s
Iteration   5: 0.620 ops/s


Result "jvbench.swaptions.SwaptionsPatternBenchmark.indexInRange":
  0.601 ±(99.9%) 0.017 ops/s [Average]
  (min, avg, max) = (0.566, 0.601, 0.627), stdev = 0.023
  CI (99.9%): [0.584, 0.618] (assumes normal distribution)


# Run complete. Total time: 00:09:08

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

NOTE: Current JVM experimentally supports Compiler Blackholes, and they are in use. Please exercise
extra caution when trusting the results, look into the generated code to check the benchmark still
works, and factor in a small probability of new VM bugs. Additionally, while comparisons between
different JVMs are already problematic, the performance difference caused by different Blackhole
modes can be very significant. Please make sure you use the consistent Blackhole mode for comparisons.

Benchmark                                Mode  Cnt  Score   Error  Units
SwaptionsPatternBenchmark.indexInRange  thrpt   25  0.601 ± 0.017  ops/s
